%%-----------------------------------------------------------
%% Various developments for untyped STLC with pairs and nums
%%-----------------------------------------------------------

exp : type.
%name exp E x.

z : exp.
s : exp -> exp.
fst : exp -> exp.
snd : exp -> exp.
pair : exp -> exp -> exp.
lam : (exp -> exp) -> exp.
app : exp -> exp -> exp.

id-exp : exp -> exp -> type.
id-exp/refl : id-exp T T.

%%-----------------------------------------------
%% Values and properties of their equality
%%-----------------------------------------------

%% Values

value : exp -> type.
%name value V v.

val/z : value z.
val/s : value V -> value (s V).
val/pair : value V1 -> value V2 -> value (pair V1 V2).
val/lam : {F: exp -> exp} value (lam F).

%% Equality on values

id-val : value E1 -> value E2 -> type.
id-val/refl : id-val V V.

%% Congruence lemmas

id-val-cong-suc : id-val V1 V2 -> id-val (val/s V1) (val/s V2) -> type.
%mode id-val-cong-suc +EQ -EQS.

- : id-val-cong-suc id-val/refl id-val/refl.

%worlds () (id-val-cong-suc _ _).
%total {} (id-val-cong-suc _ _).

%%---------------------------------------------------------

id-val-cong-pair-fst :
			id-val (val/pair V1 V3) (val/pair V2 V4)
			-> id-val V1 V2
			-> type.
%mode id-val-cong-pair-fst +EQ -EQPAIR.

- : id-val-cong-pair-fst id-val/refl id-val/refl.

%worlds () (id-val-cong-pair-fst _ _).
%total {} (id-val-cong-pair-fst _ _).

%%---------------------------------------------------------

id-val-cong-pair-snd :
			id-val (val/pair V1 V3) (val/pair V2 V4)
			-> id-val V3 V4
			-> type.
%mode id-val-cong-pair-snd +EQ -EQPAIR.

- : id-val-cong-pair-snd id-val/refl id-val/refl.

%worlds () (id-val-cong-pair-snd _ _).
%total {} (id-val-cong-pair-snd _ _).

%%---------------------------------------------------------

id-val-cong-pair : id-val V1 V2
		    -> id-val V3 V4
		    -> id-val (val/pair V1 V3) (val/pair V2 V4)
		    -> type.
%mode id-val-cong-pair +EQ1 +EQ2 -EQP.

- : id-val-cong-pair id-val/refl id-val/refl id-val/refl.

%worlds () (id-val-cong-pair _ _ _).
%total {} (id-val-cong-pair _ _ _).

%%---------------------------------------------------------

id-fun-arg :  id-val (val/lam F1) (val/lam F2)
	      -> id-exp E1 E2
	      -> id-exp (F1 E1) (F2 E2)
	      -> type.
%mode id-fun-arg +F +A -R.

- : id-fun-arg id-val/refl id-exp/refl id-exp/refl.

%worlds () (id-fun-arg _ _ _).
%total {} (id-fun-arg _ _ _).

%%---------------------------------------------------------
%% Equal values become equal expressions

val2exp : {V1 : value E1}
	   {V2 : value E2}
	   id-val V1 V2
	   -> id-exp E1 E2
	   -> type.
%mode val2exp +V1 +V2 +P -R.

- : val2exp V1 V1 id-val/refl id-exp/refl.

%worlds () (val2exp _ _ _ _).
%total {} (val2exp _ _ _ _).

%%-----------------------------------------------
%% Natural semantics/direct style evaluator
%%-----------------------------------------------

%% Evaluator

eval : exp -> value V -> type.
%mode eval +E -V.

eval/z : eval z val/z.
eval/s : eval (s E) (val/s V)
	  <- eval E V.
eval/fst : eval (fst E) V1
	    <- eval E (val/pair V1 V2).
eval/snd : eval (snd E) V2
	    <- eval E (val/pair V1 V2).
eval/pair : eval (pair E1 E2) (val/pair V1 V2)
	     <- eval E1 V1
	     <- eval E2 V2.
eval/lam : eval (lam F) (val/lam F).
eval/app : eval (app E1 E2) V2
	    <- eval E1 (val/lam F)
	    <- eval E2 (V1 : value E3)
	    <- eval (F E3) V2.

%worlds () (eval _ _).

%% Lemma: values evaluate to themselves

eval/val : {V : value E} eval E V -> type.
%mode eval/val +V -EV.

- : eval/val val/z eval/z.

- : eval/val (val/s V) (eval/s EV)
     <- eval/val V EV.

- : eval/val (val/pair V1 V2) (eval/pair E2 E1)
     <- eval/val V1 E1
     <- eval/val V2 E2.

- : eval/val (val/lam F) eval/lam.

%worlds () (eval/val _ _).
%total V (eval/val V _).

%% Lemma: equal expr's evaluate to equal values

eval-eq : eval E1 V1 -> eval E2 V2 -> id-exp E1 E2 -> id-val V1 V2 -> type.

%mode eval-eq +P1 +P2 +E -EQ.

- : eval-eq eval/z eval/z id-exp/refl id-val/refl.

- : eval-eq (eval/s P1) (eval/s P2) id-exp/refl EQS
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-suc EQ EQS.

- : eval-eq (eval/fst P1) (eval/fst P2) id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair-fst EQ EQ'.

- : eval-eq (eval/snd P1) (eval/snd P2) id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair-snd EQ EQ'.

- : eval-eq (eval/pair P1 P1') (eval/pair P2 P2') id-exp/refl EQ2
     <- eval-eq P1' P2' id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair EQ' EQ EQ2.

- : eval-eq eval/lam eval/lam id-exp/refl id-val/refl.

- : eval-eq (eval/app P1 P2 P3) (eval/app R1 R2 R3) id-exp/refl EQ_R
     <- eval-eq P3 R3 id-exp/refl (EQ_F : id-val (val/lam F1) (val/lam F2)) 
     <- eval-eq P2 R2 id-exp/refl (EQ_A : id-val V1 V2)
     <- val2exp _ _ EQ_A EQ_A'
     <- id-fun-arg EQ_F EQ_A' LEMMA
     <- eval-eq P1 R1 LEMMA EQ_R.

%worlds() (eval-eq _ _ _ _).
%total P1 (eval-eq P1 _ _ _).

%%----------------------------------------------
%% Evaluator-based equality
%%----------------------------------------------

eval-equiv : eval E V1
	      -> id-val V1 V2
	      -> eval E V2
	      -> type.
%mode eval-equiv +E +V -E2.

- : eval-equiv E id-val/refl E.

%worlds () (eval-equiv _ _ _).
%total {} (eval-equiv _ _ _).

%%-----------------------------------------------

eval-equiv-arg : eval E1 V
	      -> id-exp E1 E2
	      -> eval E2 V
	      -> type.
%mode eval-equiv-arg +E +V -E2.

- : eval-equiv-arg E id-exp/refl E.

%worlds () (eval-equiv-arg _ _ _).
%total {} (eval-equiv-arg _ _ _).

%%-----------------------------------------------------------

== : exp -> exp -> type.            %infix right 10 == .

eq : E1 == E2            
      <- eval E2 V
      <- eval E1 V.

eq-fst : E1 == E2 -> eval (fst E1) V -> eval (fst E2) V -> type.
%mode eq-fst +D +F1 -F2.

- : eq-fst (eq V1 V2) (eval/fst E) (eval/fst E')
     <- eval-eq V1 E id-exp/refl VAL_EQ
     <- eval-equiv V2 VAL_EQ E'.

%worlds () (eq-fst _ _ _).
%total D (eq-fst D _ _).

%%% -------

%% CONTINUE

%% THEOREM: E1 == E2    implies   S[E1] == S[E2]


%%-----------------------------------------------
%% Abstract machine
%%-----------------------------------------------

frame : type.
%name frame F f.

f-s : frame.
f-fst : frame.
f-snd : frame.
f-pair1 : exp -> frame.
f-pair2 : value V -> frame.
f-app1 : exp -> frame.
f-app2 : value V -> frame.

stack : type.
%name stack S s.

nil : stack.
, : frame -> stack -> stack.        %infix right 10 , .

state : type.
%name state ST.

ev : exp -> stack -> state.
ap : value E -> stack -> state.

=AM=> : state -> state -> type.
%infix right 10 =AM=> .
%name =AM=> D.
%mode =AM=> +PREV -NEXT.

ev/z :
	ev z S
	=AM=>
	ap val/z S.

ev/s : 
	ev (s E) S
	=AM=>
	ev E (f-s , S).

ap/s : 
	ap V (f-s , S)
	=AM=>
	ap (val/s V) S.

ev/fst : 
	  ev (fst E) S
	  =AM=>
	  ev E (f-fst , S).

ap/fst : 
	  ap (val/pair V1 V2) (f-fst , S)
	  =AM=>
	  ap V1 S.

ev/snd : 
	  ev (snd E) S
	  =AM=>
	  ev E (f-snd , S).

ap/snd :
	  ap (val/pair V1 V2) (f-snd , S)
	  =AM=>
	  ap V2 S.

ev/pair1 : 
	    ev (pair E1 E2) S
	    =AM=>
	    ev E1 (f-pair1 E2 , S).

ap/pair1 :
	    ap V1 (f-pair1 E2 , S)
	    =AM=>
	    ev E2 (f-pair2 V1 , S).

ap/pair2 : 
	    ap V2 (f-pair2 V1 , S)
	    =AM=>
	    ap (val/pair V1 V2) S.

ev/lam : 
	  ev (lam F) S
	  =AM=>
	  ap (val/lam F) S.

ev/app1 : 
	   ev (app E1 E2) S
	   =AM=>
	   ev E1 (f-app1 E2 , S).

ap/app1 : 
	   ap V (f-app1 E2 , S)
	   =AM=>
	   ev E2 (f-app2 V , S).

ap/app2 : 
	   ap (V2 : value E) (f-app2 (val/lam F) , S)
	   =AM=>
	   ev (F E) S.

%worlds () (=AM=> _ _).

%% Reflexive Transitive closure

===>+ : state -> state -> type.
%infix right 10 ===>+ .
%name ===>+ STEPS.
%mode ===>+ +START -END.

am-many/z :
	     ST ===>+ ST.

am-many/s :
	     ST1 ===>+ ST3
	     <- ST1 =AM=> ST2
	     <- ST2 ===>+ ST3.

%worlds () (===>+ _ _).


%%--------------------------------------------------------------
%% Eval => AM
%%--------------------------------------------------------------

%% Append lemma

am-app: ST1 ===>+ ST2 -> ST2 ===>+ ST3 -> ST1 ===>+ ST3 -> type.
%mode am-app +STM1 +STM2 -STM3.

- : am-app am-many/z STEP2 STEP2.

- : am-app (am-many/s STEP S1) STEP2 (am-many/s STEP3 S1)
     <- am-app STEP STEP2 STEP3.

%worlds () (am-app _ _ _).
%total S (am-app S _ _).

%% The main theorem

eval2machine : {S : stack} eval E V -> ev E S ===>+ ap V S -> type.
%mode eval2machine +S +EV -AM.

- : eval2machine S eval/z (am-many/s am-many/z ev/z).

- : eval2machine S (eval/s D) (am-many/s GOAL ev/s)
     <- eval2machine (f-s , S) D LEMMA
     <- am-app LEMMA (am-many/s am-many/z ap/s) GOAL.

- : eval2machine S (eval/fst D) (am-many/s GOAL ev/fst)
     <- eval2machine (f-fst , S) D LEMMA
     <- am-app LEMMA (am-many/s am-many/z ap/fst) GOAL.

- : eval2machine S (eval/snd D) (am-many/s GOAL ev/snd)
     <- eval2machine (f-snd , S) D LEMMA
     <- am-app LEMMA (am-many/s am-many/z ap/snd) GOAL.

- : eval2machine S (eval/pair D1 D2) (am-many/s GOAL ev/pair1)
     <- eval2machine (f-pair1 _ , S) D2 LEMMA1
     <- eval2machine (f-pair2 _ , S) D1 LEMMA2
     <- am-app LEMMA1 (am-many/s LEMMA2 ap/pair1) LEMMA3
     <- am-app LEMMA3 (am-many/s am-many/z ap/pair2) GOAL.

- : eval2machine S (eval/lam) (am-many/s am-many/z ev/lam).

- : eval2machine S (eval/app D3 D2 D1) (am-many/s GOAL ev/app1)
     <- eval2machine (f-app1 _ , S) D1 LEMMA1
     <- eval2machine (f-app2 _ , S) D2 LEMMA2
     <- eval2machine S D3 LEMMA4
     <- am-app LEMMA1 (am-many/s LEMMA2 ap/app1) LEMMA3
     <- am-app LEMMA3 (am-many/s LEMMA4 ap/app2) GOAL.

%worlds () (eval2machine _ _ _).
%total EV (eval2machine _ EV _).

%%--------------------------------------------------------------
%% Equivalence theorems
%%--------------------------------------------------------------

machine2eval : ev E S ===>+ ap V S -> eval E V -> type.

% %%-------------------------------------------
% %% Plugging the expressions in the stacks
% %%-------------------------------------------

% plug : exp -> stack -> exp -> type.
% %mode plug +E +S -E2.

% plug/nil : plug E nil E.
% plug/s : plug E (f-s , S) E'
% 	  <- plug (s E) S E'.
% plug/fst : plug E (f-fst , S) E'
% 	    <- plug (fst E) S E'.
% plug/snd : plug E (f-snd , S) E'
% 	    <- plug (snd E) S E'.
% plug/pair1 : plug E (f-pair1 E2 , S) E'
% 	    <- plug (pair E E2) S E'.
% plug/pair2 : plug E (f-pair2 (V : value E1) , S) E'
% 	      <- plug (pair E1 E) S E'.
% plug/app1 : plug E (f-app1 E2 , S) E'
% 	     <- plug (app E E2) S E'.
% plug/app2 : plug E (f-app2 (V : value F) , S) E'
% 	    <- plug (app F E) S E'.

% %worlds () (plug _ _ _).
% %total S (plug _ S _).

% %% Flattenning the states into expressions

% flat : state -> exp -> type.
% %mode flat +S -E.

% flat/ev : flat (ev E S) E'
% 	   <- plug E S E'.

% flat/ap : flat (ap (V : value E) S) E'
% 	   <- plug E S E'.

% %worlds () (flat _ _).
% %total S (flat S _).

% %%------------------------------------------
% %% Lemma: result of plug is unique

% plug-eq : plug E S X1 -> plug E S X2 -> id-exp X1 X2 -> type.

% %mode plug-eq +P1 +P2 -EQ.

% - : plug-eq plug/nil plug/nil id-exp/refl.

% - : plug-eq (plug/s P1) (plug/s P2) EQ
%      <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/fst P1) (plug/fst P2) EQ
%     <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/snd P1) (plug/snd P2) EQ
%     <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/pair1 P1) (plug/pair1 P2) EQ
%     <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/pair2 P1) (plug/pair2 P2) EQ
%     <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/app1 P1) (plug/app1 P2) EQ
%     <- plug-eq P1 P2 EQ.

% - : plug-eq (plug/app2 P1) (plug/app2 P2) EQ
%     <- plug-eq P1 P2 EQ.

% %worlds () (plug-eq _ _ _).
% %total P1 (plug-eq P1 _ _).

% %%-----------------------------------------
% %% Eval-equivalent pairs
% %%----------------------------------------

% equal-fst-pair :
% 		  value E1
% 		  -> value E2
% 		  -> E1 == fst (pair E1 E2)
% 		  -> type.
% %mode equal-fst-pair +V1 +V2 -EQ.

% - : equal-fst-pair V1 V2 (eq EQ1 (eval/fst (eval/pair EQ2 EQ1)))
%      <- eval/val V1 EQ1
%      <- eval/val V2 EQ2.

% %worlds () (equal-fst-pair _ _ _).
% %total {} (equal-fst-pair _ _ _).

% %%-----------------------------------------------

% equal-snd-pair :
% 		  value E1
% 		  -> value E2
% 		  -> E2 == snd (pair E1 E2)
% 		  -> type.
% %mode equal-snd-pair +V1 +V2 -EQ.

% - : equal-snd-pair V1 V2 (eq EQ2 (eval/snd (eval/pair EQ2 EQ1)))
%      <- eval/val V1 EQ1
%      <- eval/val V2 EQ2.

% %worlds () (equal-snd-pair _ _ _).
% %total {} (equal-snd-pair _ _ _).

% %%-----------------------------------------------

% eval-plug-beta :
% 		  value E
% 		  -> plug (F E) S E1
% 		  -> eval E1 V
% 		  -> plug (app (lam F) E) S E2
% 		  -> eval E2 V
% 		  -> type.

% plug (F E) S E1
% eval E1 V
% eval (F E) V'

% plug (F E) (fst , S) = plug (fst (F E)) S E1
% 			eval (plug (fst (F E) S)) V

% E1 == E2 -> eval E1 === eval E2
		     

% % %%-----------------------------------------------

% plug E S E'

% eval E V

% eval E' V'

% ev E S ===> ev V S                  ---> E ==> V

% ev E (fst :: S) ===> ev V S         ---> fst E ==> V

% ev E (snd :: S) ===> ev V S         ---> snd E ==> V

% ev E (pair1 E2 :: S) ==> ev V S      ---> pair E E2 ==> V

% ev E (pair2 V1 :: S) ==> ev V S      ---> pair V1 E ===> V

% ev E (app1 A :: S) ==> ev V S     ---> pair (E A) ===> V

% ev E (app2 F :: S) ==> ev V S     ---> pair (F E) ===> V

% ===============================

% ev (fst E) S -> ev E (fst :: S)

% ev V (fst :: S) -> ap V 

% % equal-beta :
% % 	      value E
% % 	      -> eval (F E) V
% % 	      -> F E == app (lam F) E

% % %%-----------------------------------------------

% % eval-plug-eq : eval E1 V2
% % 		-> eval E2 V2
% % 		-> plug E1 S ES1
% % 		-> plug E2 S ES2
% % 		-> eval ES1 V
% % 		-> eval ES2 V.

% % %%-------------------------------------------
% % %
% % %

% % inv : ST1 =AM=> ST2
% %        -> flat ST1 E1
% %        -> flat ST2 E2
% %        -> eval E2 V
% %        -> eval E1 V
% %        -> type.

% ev E1 S ==> ev E1' S'

% % %mode inv +STEP +FLAT1 +FLAT2 +EVAL2 -EVAL1.

% % - : inv ev/s (flat/ev P1) (flat/ev (plug/s P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ap/s (flat/ap (plug/s P1)) (flat/ap P2) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ev/fst (flat/ev P1) (flat/ev (plug/fst P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % % %% Non-trivial case, because we contract a redex here
% % % %% fst (V1 V2) ---> V1

% % % {V1:value E1}
% % % {V2:value E2}
% % % {V3:value E5}
% % % {P1:plug (fst (pair E1 E2)) S1 E3}
% % % {P2:plug E1 S1 E4}
% % % {EV2:eval E4 V3}
% % % ====================
% % % {EV23:eval E3 V3}

% % - : inv ap/fst (flat/ap (plug/fst P1)) (flat/ap P2) EV2 EV23.

% % - : inv ev/snd (flat/ev P1) (flat/ev (plug/snd P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % % %% Here also a redex is contracted
% % % %% fst (V1 V2) ---> V2
% % % %% - : inv (ap/snd) F1 F2 EV2 EV23.

% % - : inv ev/pair1 (flat/ev P1) (flat/ev (plug/pair1 P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ap/pair1 (flat/ap (plug/pair1 P1)) (flat/ev (plug/pair2 P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ap/pair2 (flat/ap (plug/pair2 P1)) (flat/ap P2) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ev/lam (flat/ev P1) (flat/ap P2) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ev/app1 (flat/ev P1) (flat/ev (plug/app1 P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % - : inv ap/app1 (flat/ap (plug/app1 P1)) (flat/ev (plug/app2 P2)) EV EV2
% %      <- plug-eq P2 P1 EQ
% %      <- eval-equiv-arg EV EQ EV2.

% % %% {P1:plug (app (lam ([x:exp] X3 x)) X1) X4 X5}
% % %% {P2:plug (X3 X1) X4 X6}
% % %% {EV:eval X6 X8} {EV2:eval X5 X8}
% % % - : inv ap/app2 (flat/ap (plug/app2 P1)) (flat/ev P2) EV EV2.


% % %worlds () (inv _ _ _  _ _).
% % %total STEP (inv STEP _ _ _ _).

% % thm : {e : exp} {v : value E'}
% %        ev E nil =AM=> ap V nil
% %        -> eval E V
% %        -> type.

% % %mode thm +E +V +STEP -EV.

% % - : thm E (V : value E') STEP EVV
% %      <- eval/val V EV_V
% %      <- inv STEP
% % 	(flat/ev plug/nil : flat _ E)
% % 	(flat/ap plug/nil : flat _ E')
% % 	EV_V
% % 	EVV.


% % %worlds () (thm _ _ _ _).
% % %total STEP (thm _ _ STEP _).


