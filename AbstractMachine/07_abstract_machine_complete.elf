%%-------------------------------------------
%% Plugging the expressions in the stacks
%%-------------------------------------------

plug : exp -> stack -> exp -> type.
%mode plug +E +S -E2.

plug/nil : plug E nil E.
plug/s : plug E (f-s , S) E'
	  <- plug (s E) S E'.
plug/fst : plug E (f-fst , S) E'
	    <- plug (fst E) S E'.
plug/snd : plug E (f-snd , S) E'
	    <- plug (snd E) S E'.
plug/pair1 : plug E (f-pair1 E2 , S) E'
	    <- plug (pair E E2) S E'.
plug/pair2 : plug E (f-pair2 (V : value E1) , S) E'
	      <- plug (pair E1 E) S E'.
plug/app1 : plug E (f-app1 E2 , S) E'
	     <- plug (app E E2) S E'.
plug/app2 : plug E (f-app2 (V : value F) , S) E'
	    <- plug (app F E) S E'.

%worlds () (plug _ _ _).
%total S (plug _ S _).

%%----------------------------------------

get-plug : {E : exp}{S : stack} {E' : exp} plug E S E' -> type.
%mode get-plug +E +S -E' -PLUG.

- : get-plug E nil E plug/nil.
- : get-plug E (f-s , S) E' (plug/s D)
     <- get-plug (s E) S E' D.
- : get-plug E (f-fst , S) E' (plug/fst D)
     <- get-plug (fst E) S E' D.
- : get-plug E (f-snd , S) E' (plug/snd D)
     <- get-plug (snd E) S E' D.
- : get-plug E (f-pair1 E2 , S) E' (plug/pair1 D)
     <- get-plug (pair E E2) S E' D.
- : get-plug E (f-pair2 (V : value E1) , S) E' (plug/pair2 D)
     <- get-plug (pair E1 E) S E' D.
- : get-plug E (f-app1 E2 , S) E' (plug/app1 D)
     <- get-plug (app E E2) S E' D.
- : get-plug E (f-app2 (V : value F) , S) E' (plug/app2 D)
     <- get-plug (app F E) S E' D.

%worlds () (get-plug _ _ _ _).
%total S (get-plug _ S _ _).



%% Flattenning the states into expressions

flat : state -> exp -> type.
%mode flat +S -E.

flat/ev : flat (ev E S) E'
	   <- plug E S E'.

flat/ap : flat (ap (V : value E) S) E'
	   <- plug E S E'.

%worlds () (flat _ _).
%total S (flat S _).

%%------------------------------------

get-flat : {ST : state} {E : exp} flat ST E -> type.
%mode get-flat +S -E -FLAT.

- : get-flat (ev E1 S) E (flat/ev LEMMA)
     <- get-plug E1 S E LEMMA.

- : get-flat (ap (V : value E1) S) E (flat/ap LEMMA)
     <- get-plug E1 S E LEMMA.

%worlds () (get-flat _ _ _).
%total S (get-flat S _ _).

%%------------------------------------------
%% Lemma: result of plug is unique

plug-eq : plug E S X1 -> plug E S X2 -> id-exp X1 X2 -> type.

%mode plug-eq +P1 +P2 -EQ.

- : plug-eq plug/nil plug/nil id-exp/refl.

- : plug-eq (plug/s P1) (plug/s P2) EQ
     <- plug-eq P1 P2 EQ.

- : plug-eq (plug/fst P1) (plug/fst P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/snd P1) (plug/snd P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair1 P1) (plug/pair1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair2 P1) (plug/pair2 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app1 P1) (plug/app1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app2 P1) (plug/app2 P2) EQ
    <- plug-eq P1 P2 EQ.

%worlds () (plug-eq _ _ _).
%total P1 (plug-eq P1 _ _).

%% Result of flat is unique : 

flat-eq : flat S E1 -> flat S E2 -> id-exp E1 E2 -> type.

%mode flat-eq +P1 +P2 -EQ.

- : flat-eq (flat/ev S1) (flat/ev S2) GOAL
     <- plug-eq S1 S2 GOAL.

- : flat-eq (flat/ap S1) (flat/ap S2) GOAL
     <- plug-eq S1 S2 GOAL.

%worlds () (flat-eq _ _ _).
%total P1 (flat-eq P1 _ _).

%%-------------------------------------------------------
%% E1 <= E2       implies     eval E1 V  implies eval E2 V
%
%% Reflexive and transitive closure of the reduction relation
%%-----------------------------------------------------------

implies : exp -> exp -> type.
%mode implies +E1 -E2.

% reduction rules
imp/fst-pair : implies (fst (pair E1 E2)) E1
		<- value E2
		<- value E1.
imp/snd-pair : implies (snd (pair E1 E2)) E2
		<- value E2
		<- value E1.
imp/beta : implies (app (lam F) E) E'
	    <- id-exp (F E) E'
	    <- value E.

% congruence rules
imp/z : implies z z.
imp/s : implies (s E1) (s E2) <- implies E1 E2.
imp/fst : implies (fst E1) (fst E2) <- implies E1 E2.
imp/snd : implies (snd E1) (snd E2) <- implies E1 E2.
imp/pair : implies (pair E1 E2) (pair E1' E2')
	    <- implies E2 E2'
	    <- implies E1 E1'.
imp/lam : implies (lam F) (lam F).
imp/app : implies (app E1 E2) (app E1' E2')
	    <- implies E2 E2'
	    <- implies E1 E1'.

% imp/trans : implies E1 E3
% 	     <- implies E1 E2
% 	     <- implies E2 E3.

%worlds () (implies _ _).
%terminates E (implies E _).

%%---------------------------------------------

imp-refl : {E : exp} implies E E -> type.
%mode imp-refl +E -IMPLIES.

- : imp-refl z imp/z.
- : imp-refl (s E) (imp/s D) <- imp-refl E D.
- : imp-refl (fst E) (imp/fst D) <- imp-refl E D.
- : imp-refl (snd E) (imp/snd D) <- imp-refl E D.
- : imp-refl (lam F) imp/lam.
- : imp-refl (pair E1 E2) (imp/pair D1 D2)
     <- imp-refl E1 D1
     <- imp-refl E2 D2.
- : imp-refl (app E1 E2) (imp/app D1 D2)
     <- imp-refl E1 D1
     <- imp-refl E2 D2.

%worlds () (imp-refl _ _).
%total E (imp-refl E _).

%%-----------------------------------------------------

imp-eval-lemma:
		 value E
		 -> id-exp (F E) E'
		 -> eval E' V
		 -> eval (app (lam F) E) V
		 -> type.
%mode imp-eval-lemma +V +EQ +EV2 -EV.

- : imp-eval-lemma V id-exp/refl EV (eval/app EV ARG eval/lam)
     <- eval/val V ARG.

%worlds () (imp-eval-lemma _ _ _ _).
%total {} (imp-eval-lemma _ _ _ _).

%%-------------------------------------------------

imp-eval : implies E1 E2 -> eval E2 V -> eval E1 V -> type.
%mode imp-eval +IMP +EV2 -EV1.

- : imp-eval (imp/beta V EQ) EV2 GOAL
     <- imp-eval-lemma V EQ EV2 GOAL.

- : imp-eval (imp/fst-pair V1 V2) EV2 (eval/fst (eval/pair OUT EV2))
     <- eval/val V2 OUT.

- : imp-eval (imp/snd-pair V1 V2) EV2 (eval/snd (eval/pair EV2 P2))
     <- eval/val V1 P2.

- : imp-eval imp/z E E.

- : imp-eval (imp/s IMP) (eval/s D) (eval/s D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/fst IMP) (eval/fst D) (eval/fst D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/snd IMP) (eval/snd D) (eval/snd D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/pair B A) (eval/pair D1 D2) (eval/pair D1' D2')
     <- imp-eval A D1 D1'
     <- imp-eval B D2 D2'.

- : imp-eval imp/lam E E.

- : imp-eval (imp/app B A) (eval/app RES2 ARG FUN) (eval/app RES2 ARG2 FUN2)
     <- imp-eval B FUN FUN2
     <- imp-eval A ARG ARG2.

%worlds () (imp-eval _ _ _).
%total I (imp-eval I _ _).

%%--------------------------------------------------------

imp-ctx : {S : stack}
	   implies E1 E2
	   -> plug E1 S E1'
	   -> plug E2 S E2'
	   -> implies E1' E2'
	   -> type.
%mode imp-ctx +S +IMP +P1 +P2 -IMP2.

- : imp-ctx nil IMP plug/nil plug/nil IMP.

- : imp-ctx (f-s , S) IMP (plug/s P1) (plug/s P2) LEMMA
     <- imp-ctx S (imp/s IMP) P1 P2 LEMMA.

- : imp-ctx (f-fst , S) IMP (plug/fst P1) (plug/fst P2) LEMMA
     <- imp-ctx S (imp/fst IMP) P1 P2 LEMMA.

- : imp-ctx (f-snd , S) IMP (plug/snd P1) (plug/snd P2) LEMMA
     <- imp-ctx S (imp/snd IMP) P1 P2 LEMMA.

- : imp-ctx (f-pair1 E , S) IMP (plug/pair1 P1) (plug/pair1 P2) LEMMA
     <- imp-refl E IMP2
     <- imp-ctx S (imp/pair IMP IMP2) P1 P2 LEMMA.

- : imp-ctx (f-pair2 (V : value E) , S) IMP (plug/pair2 P1) (plug/pair2 P2)
     LEMMA
     <- imp-refl E IMP2
     <- imp-ctx S (imp/pair IMP2 IMP) P1 P2 LEMMA.

- : imp-ctx (f-app1 E , S) IMP (plug/app1 P1) (plug/app1 P2) LEMMA
     <- imp-refl E IMP2
     <- imp-ctx S (imp/app IMP IMP2) P1 P2 LEMMA.

- : imp-ctx (f-app2 (V : value E) , S) IMP (plug/app2 P1) (plug/app2 P2) LEMMA
     <- imp-refl E IMP2
     <- imp-ctx S (imp/app IMP2 IMP) P1 P2 LEMMA.

%worlds () (imp-ctx _ _ _ _ _).
%total S (imp-ctx S _ _ _ _).

%%--------------------------------------------------------

inv : ST1 =AM=> ST2
       -> flat ST1 E1
       -> flat ST2 E2
       -> eval E2 V
       -> eval E1 V
       -> type.

%mode inv +STEP +FLAT1 +FLAT2 +EVAL2 -EVAL1.

- : inv ev/z (flat/ev P1) (flat/ap P2) EV GOAL
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ GOAL.

- : inv ev/s (flat/ev P1) (flat/ev (plug/s P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/s (flat/ap (plug/s P1)) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/fst (flat/ev P1) (flat/ev (plug/fst P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

% %% Non-trivial case, because we contract a redex here
% %% fst (V1 V2) ---> V1

-  : inv (ap/fst : ap (val/pair V1 V2) _ =AM=> _)
      (flat/ap (plug/fst P1)) (flat/ap P2) EV EV3
      <- imp-ctx _ (imp/fst-pair V1 V2) P1 P2 GOAL
      <- imp-eval GOAL EV EV3.

- : inv ev/snd (flat/ev P1) (flat/ev (plug/snd P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

% %% Here also a redex is contracted
% %% fst (V1 V2) ---> V2
% %% - : inv (ap/snd) F1 F2 EV2 EV23.

-  : inv (ap/snd : ap (val/pair V1 V2) _ =AM=> _)
      (flat/ap (plug/snd P1)) (flat/ap P2) EV EV3
      <- imp-ctx _ (imp/snd-pair V1 V2) P1 P2 GOAL
      <- imp-eval GOAL EV EV3.

- : inv ev/pair1 (flat/ev P1) (flat/ev (plug/pair1 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/pair1 (flat/ap (plug/pair1 P1)) (flat/ev (plug/pair2 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/pair2 (flat/ap (plug/pair2 P1)) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/lam (flat/ev P1) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/app1 (flat/ev P1) (flat/ev (plug/app1 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/app1 (flat/ap (plug/app1 P1)) (flat/ev (plug/app2 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

%% The third and final non-trivial case,
%% A beta reduction is performed here.

- : inv (ap/app2 : ap (V : value E) _ =AM=> _)
     (flat/ap (plug/app2 P1)) (flat/ev P2) EV EV2
     <- imp-ctx _ (imp/beta V id-exp/refl) P1 P2 GOAL
     <- imp-eval GOAL EV EV2.

%worlds () (inv _ _ _  _ _).
%total STEP (inv STEP _ _ _ _).

%%--------------------------------------------------

inv-many : ST1 ===>+ ST2
	    -> flat ST1 E1
	    -> flat ST2 E2
	    -> eval E2 V
	    -> eval E1 V
	    -> type.

%mode inv-many +STEP +FLAT1 +FLAT2 +EVAL2 -EVAL1.

- : inv-many am-many/z F1 F2 EV GOAL
     <- flat-eq F2 F1 EQ
     <- eval-equiv-arg EV EQ GOAL.

- : inv-many (am-many/s STEPS (STEP : _ =AM=> ST3)) F1 F2 EV GOAL
     <- get-flat ST3 E3 F3
     <- inv-many STEPS F3 F2 EV LEMMA
     <- inv STEP F1 F3 LEMMA GOAL.

%worlds () (inv-many _ _ _  _ _).
%total STEP (inv-many STEP _ _ _ _).


%%----------------------------------------------------
%% COMPLETENESS OF THE ABSTRACT MACHINE
%%----------------------------------------------------

complete:
	    ev E nil ===>+ ap V nil
	    -> eval E V
	    -> type.

%mode complete +STEPS -EVAL.

- : complete STEPS (GOAL : eval E V)
     <- eval/val V EV
     <- inv-many STEPS
	(flat/ev plug/nil)
	(flat/ap plug/nil)
	EV
	GOAL.

%worlds () (complete _ _).
%total STEPS (complete STEPS _ ).
