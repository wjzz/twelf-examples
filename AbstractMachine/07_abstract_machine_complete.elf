%%-------------------------------------------
%% Plugging the expressions in the stacks
%%-------------------------------------------

plug : exp -> stack -> exp -> type.
%mode plug +E +S -E2.

plug/nil : plug E nil E.
plug/s : plug E (f-s , S) E'
	  <- plug (s E) S E'.
plug/fst : plug E (f-fst , S) E'
	    <- plug (fst E) S E'.
plug/snd : plug E (f-snd , S) E'
	    <- plug (snd E) S E'.
plug/pair1 : plug E (f-pair1 E2 , S) E'
	    <- plug (pair E E2) S E'.
plug/pair2 : plug E (f-pair2 (V : value E1) , S) E'
	      <- plug (pair E1 E) S E'.
plug/app1 : plug E (f-app1 E2 , S) E'
	     <- plug (app E E2) S E'.
plug/app2 : plug E (f-app2 (V : value F) , S) E'
	    <- plug (app F E) S E'.

%worlds () (plug _ _ _).
%total S (plug _ S _).

%% Flattenning the states into expressions

flat : state -> exp -> type.
%mode flat +S -E.

flat/ev : flat (ev E S) E'
	   <- plug E S E'.

flat/ap : flat (ap (V : value E) S) E'
	   <- plug E S E'.

%worlds () (flat _ _).
%total S (flat S _).

%%------------------------------------------
%% Lemma: result of plug is unique

plug-eq : plug E S X1 -> plug E S X2 -> id-exp X1 X2 -> type.

%mode plug-eq +P1 +P2 -EQ.

- : plug-eq plug/nil plug/nil id-exp/refl.

- : plug-eq (plug/s P1) (plug/s P2) EQ
     <- plug-eq P1 P2 EQ.

- : plug-eq (plug/fst P1) (plug/fst P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/snd P1) (plug/snd P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair1 P1) (plug/pair1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair2 P1) (plug/pair2 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app1 P1) (plug/app1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app2 P1) (plug/app2 P2) EQ
    <- plug-eq P1 P2 EQ.

%worlds () (plug-eq _ _ _).
%total P1 (plug-eq P1 _ _).

%%-------------------------------------------------------
%% E1 <= E2       implies     eval E1 V  implies eval E2 V
%
%% Reflexive and transitive closure of the reduction relation
%%-----------------------------------------------------------

implies : exp -> exp -> type.
%mode implies +E1 -E2.

% reduction rules
imp/fst-pair : implies (fst (pair E1 E2)) E1
		<- value E2
		<- value E1.
imp/snd-pair : implies (snd (pair E1 E2)) E2
		<- value E2
		<- value E1.
imp/beta : implies (app (lam F) E) E'
	    <- id-exp (F E) E'
	    <- value E.

% congruence rules
imp/z : implies z z.
imp/s : implies (s E1) (s E2) <- implies E1 E2.
imp/fst : implies (fst E1) (fst E2) <- implies E1 E2.
imp/snd : implies (snd E1) (snd E2) <- implies E1 E2.
imp/pair : implies (pair E1 E2) (pair E1' E2')
	    <- implies E2 E2'
	    <- implies E1 E1'.
imp/lam : implies (lam F) (lam F).
imp/app : implies (app E1 E2) (app E1' E2')
	    <- implies E2 E2'
	    <- implies E1 E1'.

% imp/trans : implies E1 E3
% 	     <- implies E1 E2
% 	     <- implies E2 E3.

%worlds () (implies _ _).
%terminates E (implies E _).

%%---------------------------------------------

imp-refl : {E : exp} implies E E -> type.
%mode imp-refl +E -IMPLIES.

- : imp-refl z imp/z.
- : imp-refl (s E) (imp/s D) <- imp-refl E D.
- : imp-refl (fst E) (imp/fst D) <- imp-refl E D.
- : imp-refl (snd E) (imp/snd D) <- imp-refl E D.
- : imp-refl (lam F) imp/lam.
- : imp-refl (pair E1 E2) (imp/pair D1 D2)
     <- imp-refl E1 D1
     <- imp-refl E2 D2.
- : imp-refl (app E1 E2) (imp/app D1 D2)
     <- imp-refl E1 D1
     <- imp-refl E2 D2.

%worlds () (imp-refl _ _).
%total E (imp-refl E _).

%%-----------------------------------------------------

imp-eval-lemma:
		 value E
		 -> id-exp (F E) E'
		 -> eval E' V
		 -> eval (app (lam F) E) V
		 -> type.
%mode imp-eval-lemma +V +EQ +EV2 -EV.

- : imp-eval-lemma V id-exp/refl EV (eval/app EV ARG eval/lam)
     <- eval/val V ARG.

%worlds () (imp-eval-lemma _ _ _ _).
%total {} (imp-eval-lemma _ _ _ _).

%%-------------------------------------------------

imp-eval : implies E1 E2 -> eval E2 V -> eval E1 V -> type.
%mode imp-eval +IMP +EV2 -EV1.

- : imp-eval (imp/beta V EQ) EV2 GOAL
     <- imp-eval-lemma V EQ EV2 GOAL.

- : imp-eval (imp/fst-pair V1 V2) EV2 (eval/fst (eval/pair OUT EV2))
     <- eval/val V2 OUT.

- : imp-eval (imp/snd-pair V1 V2) EV2 (eval/snd (eval/pair EV2 P2))
     <- eval/val V1 P2.

- : imp-eval imp/z E E.

- : imp-eval (imp/s IMP) (eval/s D) (eval/s D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/fst IMP) (eval/fst D) (eval/fst D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/snd IMP) (eval/snd D) (eval/snd D2)
     <- imp-eval IMP D D2.

- : imp-eval (imp/pair B A) (eval/pair D1 D2) (eval/pair D1' D2')
     <- imp-eval A D1 D1'
     <- imp-eval B D2 D2'.

- : imp-eval imp/lam E E.

- : imp-eval (imp/app B A) (eval/app RES2 ARG FUN) (eval/app RES2 ARG2 FUN2)
     <- imp-eval B FUN FUN2
     <- imp-eval A ARG ARG2.

%worlds () (imp-eval _ _ _).
%total I (imp-eval I _ _).

%%--------------------------------------------------------

imp-ctx : implies E1 E2
	   -> plug E1 S E1'
	   -> plug E2 S E2'
	   -> implies E1' E2'
	   -> type.
%mode imp-ctx +IMP +P1 +P2 -IMP2.

%worlds () (imp-ctx _ _ _ _).
%total I (imp-ctx I _ _ _).

%%--------------------------------------------------------

inv : ST1 =AM=> ST2
       -> flat ST1 E1
       -> flat ST2 E2
       -> eval E2 V
       -> eval E1 V
       -> type.

%mode inv +STEP +FLAT1 +FLAT2 +EVAL2 -EVAL1.

- : inv ev/s (flat/ev P1) (flat/ev (plug/s P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/s (flat/ap (plug/s P1)) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/fst (flat/ev P1) (flat/ev (plug/fst P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

% %% Non-trivial case, because we contract a redex here
% %% fst (V1 V2) ---> V1

-  : inv (ap/fst : ap (val/pair V1 V2) _ =AM=> _)
      (flat/ap (plug/fst P1)) (flat/ap P2) EV EV3
      <- imp-ctx (imp/fst-pair V1 V2) P1 P2 GOAL
      <- imp-eval GOAL EV EV3.

- : inv ev/snd (flat/ev P1) (flat/ev (plug/snd P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

% %% Here also a redex is contracted
% %% fst (V1 V2) ---> V2
% %% - : inv (ap/snd) F1 F2 EV2 EV23.

-  : inv (ap/snd : ap (val/pair V1 V2) _ =AM=> _)
      (flat/ap (plug/snd P1)) (flat/ap P2) EV EV3
      <- imp-ctx (imp/snd-pair V1 V2) P1 P2 GOAL
      <- imp-eval GOAL EV EV3.

- : inv ev/pair1 (flat/ev P1) (flat/ev (plug/pair1 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/pair1 (flat/ap (plug/pair1 P1)) (flat/ev (plug/pair2 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/pair2 (flat/ap (plug/pair2 P1)) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/lam (flat/ev P1) (flat/ap P2) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ev/app1 (flat/ev P1) (flat/ev (plug/app1 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv ap/app1 (flat/ap (plug/app1 P1)) (flat/ev (plug/app2 P2)) EV EV2
     <- plug-eq P2 P1 EQ
     <- eval-equiv-arg EV EQ EV2.

- : inv (ap/app2 : ap (V : value E) _ =AM=> _)
     (flat/ap (plug/app2 P1)) (flat/ev P2) EV EV2
     <- imp-ctx (imp/beta V) P1 P2 GOAL
     <- imp-eval GOAL EV EV2.

%worlds () (inv _ _ _  _ _).
%total STEP (inv STEP _ _ _ _).

% thm : {e : exp} {v : value E'}
%        ev E nil =AM=> ap V nil
%        -> eval E V
%        -> type.

% %mode thm +E +V +STEP -EV.

% - : thm E (V : value E') STEP EVV
%      <- eval/val V EV_V
%      <- inv STEP
% 	(flat/ev plug/nil : flat _ E)
% 	(flat/ap plug/nil : flat _ E')
% 	EV_V
% 	EVV.


% %worlds () (thm _ _ _ _).
% %total STEP (thm _ _ STEP _).
