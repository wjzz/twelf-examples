%%-----------------------------------------------------------
%% Various developments for untyped STLC with pairs and nums
%%-----------------------------------------------------------

exp : type.

z : exp.
s : exp -> exp.
fst : exp -> exp.
snd : exp -> exp.
pair : exp -> exp -> exp.
lam : (exp -> exp) -> exp.
app : exp -> exp -> exp.

id-exp : exp -> exp -> type.
id-exp/refl : id-exp T T.

%%-----------------------------------------------
%% Natural semantics/direct style evaluator
%%-----------------------------------------------

%% Values

value : exp -> type.

val/z : value z.
val/s : value V -> value (s V).
val/pair : value V1 -> value V2 -> value (pair V1 V2).
val/lam : {F: exp -> exp} value (lam F).

%% Equality on values

id-val : value E1 -> value E2 -> type.
id-val/refl : id-val V V.

%% Congruence lemmas

id-val-cong-suc : id-val V1 V2 -> id-val (val/s V1) (val/s V2) -> type.
%mode id-val-cong-suc +EQ -EQS.

id-val-cong/s : id-val-cong-suc id-val/refl id-val/refl.

%worlds () (id-val-cong-suc _ _).
%total {} (id-val-cong-suc _ _).

id-val-cong-pair-fst :
			id-val (val/pair V1 V3) (val/pair V2 V4)
			-> id-val V1 V2
			-> type.
%mode id-val-cong-pair-fst +EQ -EQPAIR.

id-val-cong/p1 : id-val-cong-pair-fst id-val/refl id-val/refl.

%worlds () (id-val-cong-pair-fst _ _).
%total {} (id-val-cong-pair-fst _ _).

id-val-cong-pair-snd :
			id-val (val/pair V1 V3) (val/pair V2 V4)
			-> id-val V3 V4
			-> type.
%mode id-val-cong-pair-snd +EQ -EQPAIR.

id-val-cong/p2 : id-val-cong-pair-snd id-val/refl id-val/refl.

%worlds () (id-val-cong-pair-snd _ _).
%total {} (id-val-cong-pair-snd _ _).


id-val-cong-pair : id-val V1 V2
		    -> id-val V3 V4
		    -> id-val (val/pair V1 V3) (val/pair V2 V4)
		    -> type.
%mode id-val-cong-pair +EQ1 +EQ2 -EQP.

id-val-cong/pair : id-val-cong-pair id-val/refl id-val/refl id-val/refl.

%worlds () (id-val-cong-pair _ _ _).
%total {} (id-val-cong-pair _ _ _).


id-fun-arg :  id-val (val/lam F1) (val/lam F2)
	      -> id-exp E1 E2
	      -> id-exp (F1 E1) (F2 E2)
	      -> type.
%mode id-fun-arg +F +A -R.

- : id-fun-arg id-val/refl id-exp/refl id-exp/refl.

%worlds () (id-fun-arg _ _ _).
%total {} (id-fun-arg _ _ _).

val2exp : {V1 : value E1}{V2 : value E2}
	   id-val V1 V2
	   -> id-exp E1 E2
	   -> type.
%mode val2exp +V1 +V2 +P -R.

- : val2exp V1 V1 id-val/refl id-exp/refl.

%worlds () (val2exp _ _ _ _).
%total {} (val2exp _ _ _ _).

%% Evaluator

eval : exp -> value V -> type.
%mode eval +E -V.

eval/z : eval z val/z.
eval/s : eval (s E) (val/s V)
	  <- eval E V.
eval/fst : eval (fst E) V1
	    <- eval E (val/pair V1 V2).
eval/snd : eval (snd E) V2
	    <- eval E (val/pair V1 V2).
eval/pair : eval (pair E1 E2) (val/pair V1 V2)
	     <- eval E1 V1
	     <- eval E2 V2.
eval/lam : eval (lam F) (val/lam F).
eval/app : eval (app E1 E2) V2
	    <- eval E1 (val/lam F)
	    <- eval E2 (V1 : value E3)
	    <- eval (F E3) V2.

%worlds () (eval _ _).

%% lemma 

eval/val : {V : value E} eval E V -> type.
%mode eval/val +V -EV.

- : eval/val val/z eval/z.

- : eval/val (val/s V) (eval/s EV)
     <- eval/val V EV.

- : eval/val (val/pair V1 V2) (eval/pair E2 E1)
     <- eval/val V1 E1
     <- eval/val V2 E2.

- : eval/val (val/lam F) eval/lam.

%worlds () (eval/val _ _).
%total V (eval/val V _).

%% result uniqueness

eval-eq : eval E1 V1 -> eval E2 V2 -> id-exp E1 E2 -> id-val V1 V2 -> type.

%mode eval-eq +P1 +P2 +E -EQ.

- : eval-eq eval/z eval/z id-exp/refl id-val/refl.

- : eval-eq (eval/s P1) (eval/s P2) id-exp/refl EQS
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-suc EQ EQS.

- : eval-eq (eval/fst P1) (eval/fst P2) id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair-fst EQ EQ'.

- : eval-eq (eval/snd P1) (eval/snd P2) id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair-snd EQ EQ'.

- : eval-eq (eval/pair P1 P1') (eval/pair P2 P2') id-exp/refl EQ2
     <- eval-eq P1' P2' id-exp/refl EQ'
     <- eval-eq P1 P2 id-exp/refl EQ
     <- id-val-cong-pair EQ' EQ EQ2.

- : eval-eq eval/lam eval/lam id-exp/refl id-val/refl.

- : eval-eq (eval/app P1 P2 P3) (eval/app R1 R2 R3) id-exp/refl EQ_R
     <- eval-eq P3 R3 id-exp/refl (EQ_F : id-val (val/lam F1) (val/lam F2)) 
     <- eval-eq P2 R2 id-exp/refl (EQ_A : id-val V1 V2)
     <- val2exp _ _ EQ_A EQ_A'
     <- id-fun-arg EQ_F EQ_A' LEMMA
     <- eval-eq P1 R1 LEMMA EQ_R.

%worlds() (eval-eq _ _ _ _).
%total P1 (eval-eq P1 _ _ _).

%%----------------------------------------------
%% Evaluator-based equality
%%----------------------------------------------

eval-equiv : eval E V1
	      -> id-val V1 V2
	      -> eval E V2
	      -> type.
%mode eval-equiv +E +V -E2.

- : eval-equiv E id-val/refl E.

%worlds () (eval-equiv _ _ _).
%total {} (eval-equiv _ _ _).

== : exp -> exp -> type.            %infix right 10 == .

eq : E1 == E2            
      <- eval E2 V
      <- eval E1 V.

eq-fst : E1 == E2 -> eval (fst E1) V -> eval (fst E2) V -> type.
%mode eq-fst +D +F1 -F2.

- : eq-fst (eq V1 V2) (eval/fst E) (eval/fst E')
     <- eval-eq V1 E id-exp/refl VAL_EQ
     <- eval-equiv V2 VAL_EQ E'.

%worlds () (eq-fst _ _ _).
%total D (eq-fst D _ _).

%%% -------

%% CONTINUE

%% THEOREM: E1 == E2    implies   S[E1] == S[E2]


%%-----------------------------------------------
%% Abstract machine
%%-----------------------------------------------

frame : type.

f-s : frame.
f-fst : frame.
f-snd : frame.
f-pair1 : exp -> frame.
f-pair2 : value V -> frame.
f-app1 : exp -> frame.
f-app2 : value V -> frame.


stack : type.
nil : stack.
, : frame -> stack -> stack.        %infix right 10 , .

state : type.
ev : exp -> stack -> state.
ap : value E -> stack -> state.

=AM=> : state -> state -> type.   %infix right 10 =AM=> .
%mode =AM=> +PREV -NEXT.

ev/s : 
	ev (s E) S
	=AM=>
	ev E (f-s , S).

ap/s : 
	ap V (f-s , S)
	=AM=>
	ap (val/s V) S.

ev/fst : 
	  ev (fst E) S
	  =AM=>
	  ev E (f-fst , S).

ap/fst : 
	  ap (val/pair V1 V2) (f-fst , S)
	  =AM=>
	  ap V1 S.

ev/snd : 
	  ev (snd E) S
	  =AM=>
	  ev E (f-snd , S).

ap/snd :
	  ap (val/pair V1 V2) (f-snd , S)
	  =AM=>
	  ap V2 S.

ev/pair1 : 
	    ev (pair E1 E2) S
	    =AM=>
	    ev E1 (f-pair1 E2 , S).

ap/pair1 :
	    ap V1 (f-pair1 E2 , S)
	    =AM=>
	    ev E2 (f-pair2 V1 , S).

ap/pair2 : 
	    ap V2 (f-pair2 V1 , S)
	    =AM=>
	    ap (val/pair V1 V2) S.

ev/lam : 
	  ev (lam F) S
	  =AM=>
	  ap (val/lam F) S.

ev/app1 : 
	   ev (app E1 E2) S
	   =AM=>
	   ev E1 (f-app1 E2 , S).

ap/app1 : 
	   ap V (f-app1 E2 , S)
	   =AM=>
	   ev E2 (f-app2 V , S).

ap/app2 : 
	   ap (V2 : value E) (f-app2 (val/lam F) , S)
	   =AM=>
	   ev (F E) S.

%worlds () (=AM=> _ _).

%% Reflexive Transitive closure

===>+ : state -> state -> type.    %infix right 10 ===>+ .
%mode ===>+ +START -END.

am-many/z :
	     ST ===>+ ST.

am-many-s :
	     ST1 ===>+ ST3
	     <- ST1 =AM=> ST2
	     <- ST2 ===>+ ST3.
			      
%%--------------------------------------------------------------
%% Equivalence theorems
%%--------------------------------------------------------------

eval2machine : eval E V -> ev E S ===>+ ap V S -> type.

machine2eval : ev E S ===>+ ap V S -> eval E V -> type.

%%-------------------------------------------
%% Plugging the expressions in the stacks
%%-------------------------------------------

plug : exp -> stack -> exp -> type.
%mode plug +E +S -E2.

plug/nil : plug E nil E.
plug/s : plug E (f-s , S) E'
	  <- plug (s E) S E'.
plug/fst : plug E (f-fst , S) E'
	    <- plug (fst E) S E'.
plug/snd : plug E (f-snd , S) E'
	    <- plug (snd E) S E'.
plug/pair1 : plug E (f-pair1 E2 , S) E'
	    <- plug (pair E E2) S E'.
plug/pair2 : plug E (f-pair2 (V : value E1) , S) E'
	      <- plug (pair E1 E) S E'.
plug/app1 : plug E (f-app1 E2 , S) E'
	     <- plug (app E E2) S E'.
plug/app2 : plug E (f-app2 (V : value F) , S) E'
	    <- plug (app F E) S E'.

%worlds () (plug _ _ _).
%total S (plug _ S _).

flat : state -> exp -> type.
%mode flat +S -E.

flat/ev : flat (ev E S) E'
	   <- plug E S E'.

flat/ap : flat (ap (V : value E) S) E'
	   <- plug E S E'.

%worlds () (flat _ _).
%total S (flat S _).

%%------------------------------------------
%
%

plug-eq : plug E S X1 -> plug E S X2 -> id-exp X1 X2 -> type.

%mode plug-eq +P1 +P2 -EQ.

- : plug-eq plug/nil plug/nil id-exp/refl.

- : plug-eq (plug/s P1) (plug/s P2) EQ
     <- plug-eq P1 P2 EQ.

- : plug-eq (plug/fst P1) (plug/fst P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/snd P1) (plug/snd P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair1 P1) (plug/pair1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/pair2 P1) (plug/pair2 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app1 P1) (plug/app1 P2) EQ
    <- plug-eq P1 P2 EQ.

- : plug-eq (plug/app2 P1) (plug/app2 P2) EQ
    <- plug-eq P1 P2 EQ.

%worlds () (plug-eq _ _ _).
%total P1 (plug-eq P1 _ _).



%%-------------------------------------------
%
%

inv : ST1 =AM=> ST2
       -> flat ST1 E1
       -> flat ST2 E2
       -> eval E2 V
       -> eval E1 V
       -> type.

%mode inv +STEP +FLAT1 +FLAT2 +EVAL2 -EVAL1.

- : inv ev/s (flat/ev P1) (flat/ev (plug/s P2)) E E
     <- plug-eq P1 P2 id-exp/refl.

- : inv ap/s (flat/ap (plug/s P1)) (flat/ap P2) E E
     <- plug-eq P1 P2 id-exp/refl.

- : inv ev/fst (flat/ev P1) (flat/ev (plug/fst P2)) E E
     <- plug-eq P1 P2 id-exp/refl.

%% Non-trivial case, because we contract a redex here
%% fst (V1 V2) ---> V1
%% - : inv ap/fst (flat/ap (plug/fst P1)) (flat/ap P2) EV2 EV23.

- : inv ev/snd (flat/ev P1) (flat/ev (plug/snd P2)) E E
     <- plug-eq P1 P2 id-exp/refl.

%% Here also a redex is contracted
%% fst (V1 V2) ---> V2
%% - : inv (ap/snd) F1 F2 EV2 EV23.

- : inv ev/pair1 (flat/ev P1) (flat/ev (plug/pair1 P2)) E E
     <- plug-eq P1 P2 id-exp/refl.

- : inv ap/pair1 (flat/ap (plug/pair1 P1)) (flat/ev (plug/pair2 P2)) E E
     <- plug-eq P1 P2 id-exp/refl.

- : inv ap/pair2 (flat/ap (plug/pair2 P1)) (flat/ap P2) EV2 EV2
     <- plug-eq P1 P2 id-exp/refl.

- : inv ev/lam (flat/ev P1) (flat/ap P2) EV2 EV2
     <- plug-eq P1 P2 id-exp/refl.

- : inv ev/app1 (flat/ev P1) (flat/ev (plug/app1 P2)) EV2 EV2
     <- plug-eq P1 P2 id-exp/refl.

- : inv ap/app1 (flat/ap (plug/app1 P1)) (flat/ev (plug/app2 P2)) EV2 EV2
     <- plug-eq P1 P2 id-exp/refl.

%% {P1:plug (app (lam ([x:exp] X3 x)) X1) X4 X5}
%% {P2:plug (X3 X1) X4 X6}
%% {EV:eval X6 X8} {EV2:eval X5 X8}
- : inv ap/app2 (flat/ap (plug/app2 P1)) (flat/ev P2) EV EV2.


%worlds () (inv _ _ _  _ _).
%total STEP (inv STEP _ _ _ _).

thm : {e : exp} {v : value E'}
       ev E nil =AM=> ap V nil
       -> eval E V
       -> type.

%mode thm +E +V +STEP -EV.

- : thm E (V : value E') STEP EVV
     <- eval/val V EV_V
     <- inv STEP
	(flat/ev plug/nil : flat _ E)
	(flat/ap plug/nil : flat _ E')
	EV_V
	EVV.


%worlds () (thm _ _ _ _).
%total STEP (thm _ _ STEP _).

